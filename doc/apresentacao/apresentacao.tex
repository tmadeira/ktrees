\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage[brazil]{babel}
\usepackage{amsmath,amssymb,amsfonts,amsthm}
\usepackage{graphics}
\usepackage{hyperref}
\usepackage{tikz}

\DeclareMathOperator*{\argmax}{arg\,max}

\usetikzlibrary{positioning,shapes,arrows}

\usetheme{Copenhagen}

\title[Geração unif. de \emph{$k$-trees} para aprendizado de redes bayesianas]{\LARGE Geração uniforme de \emph{$k$-trees} para aprendizado de redes bayesianas}
\author[Tiago Madeira {\tt <madeira@ime.usp.br>}]{
  {\Large Tiago Madeira}\\
  {\footnotesize \tt <madeira@ime.usp.br>}}
\institute[IME-USP]{{\normalsize Supervisor: Prof. Dr. Denis Deratani Mauá}\\
  \ \\
  Bacharelado em Ciência da Computação\\
  Instituto de Matemática e Estatística\\
  Universidade de São Paulo}
\date{Novembro de 2016}

\begin{document}
  \frame{\titlepage}

  \section{Introdução}

  \subsection{No que consiste o trabalho?}

  \begin{frame}
    \frametitle{No que consiste o trabalho?}

    Estudo sobre amostragem uniforme de \emph{$k$-trees} e seu uso no aprendizado da estrutura de redes bayesianas com \emph{treewidth} limitado.
  \end{frame}

  \subsection{Por que estudar $k$-trees?}

  \begin{frame}
    \frametitle{Por que estudar \emph{$k$-trees}?}

    Há interesse considerável em desenvolver ferramentas eficientes para manipular \emph{$k$-trees}, porque \textbf{problemas NP-difíceis são resolvidos em tempo polinomial} em \emph{$k$-trees} e subgrafos de \emph{$k$-trees}.

    \vspace{1em}

    Alguns exemplos\footnote{\scriptsize Stefan Arnborg, Andrzej Proskurowski. Linear time algorithms for NP-Hard problems restricted to partial $k$-trees. \emph{Discrete Applied Mathematics}, 23:11--24, 1989.}:

    \begin{itemize}
      \item Encontrar tamanho máximo dos conjuntos independentes;
      \item Computar tamanho mínimo dos conjuntos dominantes;
      \item Calcular número cromático;
      \item Determinar se tem um ciclo hamiltoniano.
    \end{itemize}
  \end{frame}

  \subsection{Por que gerar $k$-trees?}

  \begin{frame}
    \frametitle{Por que gerar \emph{$k$-trees?}}

    Há muitas razões, como por exemplo para testar a eficácia de algoritmos aproximados.

    \vspace{1em}

    O problema que desperta nosso interesse é o \textbf{aprendizado de redes bayesianas}.
  \end{frame}

  \subsection{O que foi feito?}

  \begin{frame}
    \frametitle{O que foi feito?}

    \begin{itemize}
      \item Implementação do algoritmo de Caminiti \emph{et al.} (2010)\footnote{\scriptsize Severio Caminiti, Emanuele G. Fusco, Rossella Petreschi. Bijective linear time coding and decoding for $k$-trees. \emph{Theory of Computing Systems}, 46:284--300, 2010.} para \textbf{codificar \emph{$k$-trees} de forma bijetiva em tempo linear}.
      \item Implementação de algoritmo para \textbf{amostrar \emph{$k$-trees} uniformemente} e testes para comprovar seu funcionamento.
      \item Estudo sobre \textbf{aprendizado de redes bayesianas com \emph{treewidth} limitado} por meio da amostragem uniforme de \emph{$k$-trees} conforme artigo de Nie \emph{et al.} (2014)\footnote{\scriptsize Siqi Nie, Denis D. Mauá, Cassio P. de Campos, Qiang Ji. Advances in learning bayesian networks of bounded treewidth. \emph{CoRR}, abs/1406.1411, 2014.}.
      \item \textbf{Comparação entre métodos} para aprender redes bayesianas.
    \end{itemize}
  \end{frame}

%  \subsection{Onde encontrar o trabalho?}
%
%  \begin{frame}
%    \frametitle{Onde encontrar o trabalho?}
%
%    Código (desenvolvido em \emph{Go}\footnote{\scriptsize \url{https://golang.org/}}) e documentação: \url{https://github.com/tmadeira/tcc/}
%  \end{frame}

  \section{Geração uniforme de $k$-trees}

  \subsection{O que são $k$-trees?}

  \begin{frame}
    \frametitle{Primeiramente, o que são \emph{$k$-trees}?}

    Uma \textbf{\emph{$k$-tree}} é definida da seguinte forma recursiva\footnote{\scriptsize Frank Harary, Edgar M. Palmer. On acyclic simplicial complexes. \emph{Mathematika}, 15:115--122, 1968.}:

    \begin{itemize}
      \item Um grafo completo com $k$ vértices é uma \emph{$k$-tree}.
      \item Se $T_k' = (V, E)$ é uma \emph{$k$-tree}, $K \subseteq V$ é um $k$-clique e $v \not \in V$, então $T_k = (V \cup \{v\}, E \cup \{(v,x) \ | \  x \in K\})$ é uma \emph{$k$-tree}.
    \end{itemize}

    \begin{figure}
      \begin{minipage}{0.3333\textwidth}
        \centering
        \scalebox{0.5}{
          \begin{tikzpicture}
              [scale=.6,auto=left,every node/.style={draw, circle, inner sep = 0pt, minimum width = 0.72cm}]
            \node (n1) at (3,8) {1};
            \node (n2) at (1.5,6) {2};
            \node (n3) at (4.5,6) {3};
            \node (n4) at (2.25,4) {4};

            \foreach \from/\to in {n1/n2, n1/n3, n2/n4}
              \draw (\from) edge (\to);
          \end{tikzpicture}
        }

        (a)
      \end{minipage}\begin{minipage}{0.3333\textwidth}
        \centering
        \scalebox{0.5}{
          \begin{tikzpicture}
              [scale=.6,auto=left,every node/.style={draw, circle, inner sep = 0pt, minimum width = 0.72cm}]
            \node (n1) at (3,8) {1};
            \node (n2) at (5,8) {2};
            \node (n3) at (2.5,6) {3};
            \node (n4) at (6,6) {4};
            \node (n5) at (3.5,4) {5};

            \foreach \from/\to in {n1/n2, n3/n1, n3/n2, n4/n1, n4/n2, n5/n3, n5/n2}
              \draw (\from) edge (\to);
          \end{tikzpicture}
        }

        (b)
      \end{minipage}\begin{minipage}{0.3333\textwidth}
        \centering
        \scalebox{0.5}{
          \begin{tikzpicture}
              [scale=.6,auto=left,every node/.style={draw, circle, inner sep = 0pt, minimum width = 0.72cm}]
            \node (n1) at (3,8) {1};
            \node (n2) at (5,8) {2};
            \node (n3) at (7,8) {3};
            \node (n4) at (4,6) {4};
            \node (n5) at (5,4) {5};

            \foreach \from/\to in {n1/n2, n2/n3, n1/n4, n2/n4, n3/n4, n4/n5, n3/n5}
              \draw (\from) edge (\to);

            \draw (n1) edge [bend left=40] (n3);
            \draw (n1) edge [bend right=40] (n5);
          \end{tikzpicture}
        }

        (c)
      \end{minipage}

      \caption{
        \textbf{(a)} Uma \emph{$1$-tree} (ou seja, uma árvore comum) com $4$ vértices.
        \textbf{(b)} Uma \emph{$2$-tree} com $5$ vértices.
        \textbf{(c)} Uma \emph{$3$-tree} com $5$ vértices.
      }
      \label{fig:ktree}
    \end{figure}
  \end{frame}

  \begin{frame}
    \frametitle{\emph{$k$-trees} enraizadas}

    Uma \textbf{\emph{$k$-tree} enraizada} é uma \emph{$k$-tree} com um $k$-clique destacado $R = \{r_1, r_2, \cdots, r_k\}$ que é chamado de \textbf{raiz} da \emph{$k$-tree} enraizada.

    \begin{figure}
      \begin{minipage}{0.5\textwidth}
        \centering
        \scalebox{0.5}{
          \begin{tikzpicture}
              [scale=.6,auto=left,every node/.style={draw, circle, inner sep = 0pt, minimum width = 0.72cm}]
            \node (n10) at (1,9) {10};
            \node (n2) at (2.5,7) {2};
            \node (n1) at (1,4) {1};
            \node (n5) at (3,2.75) {5};
            \node (n7) at (2,1) {7};
            \node (n9) at (4.5,9.5) {9};
            \node (n6) at (4,5) {6};
            \node (n4) at (6,10.5) {4};
            \node (n3) at (8.5,6.5) {3};
            \node (n8) at (8,4.5) {8};
            \node (n11) at (9,9) {11};

            \foreach \from/\to in {n1/n2, n1/n5, n1/n7, n1/n8, n2/n3, n2/n5, n2/n6, n2/n8, n2/n9, n2/n10, n2/n11, n3/n4, n3/n5, n3/n8, n3/n9, n3/n10, n3/n11, n4/n9, n4/n11, n5/n7, n5/n8, n6/n8, n6/n9, n7/n8, n8/n9, n9/n10, n9/n11}
              \draw (\from) edge (\to);
          \end{tikzpicture}
        }

        (a)
      \end{minipage}\begin{minipage}{0.5\textwidth}
        \centering
        \scalebox{0.5}{
          \begin{tikzpicture}
              [scale=.6,auto=left,every node/.style={draw, circle, inner sep = 0pt, minimum width = 0.72cm}]
            \node (n10) at (1,8.25) {10};
            \node[fill=gray!30] (n2) at (1.5,10.5) {2};
            \node (n1) at (2,3.75) {1};
            \node (n5) at (3,6) {5};
            \node (n7) at (3.5,1.5) {7};
            \node[fill=gray!30] (n9) at (4.5,10.5) {9};
            \node (n6) at (6,6) {6};
            \node (n4) at (9,4) {4};
            \node[fill=gray!30] (n3) at (7.5,10.5) {3};
            \node (n8) at (4.5,8.25) {8};
            \node (n11) at (8,8.25) {11};

            \foreach \from/\to in {n1/n5, n1/n7, n2/n5, n2/n8, n2/n9, n2/n10, n2/n11, n3/n8, n3/n9, n3/n10, n3/n11, n4/n9, n4/n11, n5/n7, n5/n8, n6/n8, n6/n9, n8/n9, n9/n10, n9/n11}
              \draw (\from) edge (\to);

            \draw (n1) edge [bend right=20] (n8);
            \draw (n1) edge [bend left=50] (n2);
            \draw (n2) edge [bend left] (n3);
            \draw (n2) edge [bend right=20] (n6);
            \draw (n3) edge [bend left] (n4);
            \draw (n3) edge [bend left=20] (n5);
            \draw (n7) edge [bend right=20] (n8);
          \end{tikzpicture}
        }

        (b)
      \end{minipage}

      \caption{
        \textbf{(a)} Uma \emph{$3$-tree} $T_3$ com 11 vértices.
        \textbf{(b)} A mesma \emph{$3$-tree} ($T_3$) enraizada no $3$-clique $\{2, 3, 9\}$.
      }
      \label{fig:rootedktree}
    \end{figure}
  \end{frame}

  % TODO: utilidade, treewidth

  \subsection{Codificação de $k$-trees}

  \begin{frame}
    \frametitle{A relação entre geração e codificação}

    O problema de gerar \emph{$k$-trees} está intimamente relacionado ao problema de codificá-las e decodificá-las. De fato, se há uma codificação bijetiva que associa \emph{$k$-trees} a \emph{strings}, basta gerar \emph{strings} uniformemente aleatórias para gerar \emph{$k$-trees} uniformemente aleatórias.
  \end{frame}

  \begin{frame}
    \frametitle{Codificação de \emph{$k$-trees}}

    \begin{itemize}
      \item Em 1889, Cayley\footnote{\scriptsize Arthur Cayley. A theorem on trees. \emph{Quart J. Math}, 23:376--378, 1889.} demonstrou que para um conjunto de $n$ vértices existem $n^{n-2}$ árvores possíveis. Desde lá, foram criados vários códigos para árvores, como o de Prüfer\footnote{\scriptsize Heinz Prüfer. Neuer beweis eines satzes über permutationen. \emph{Archiv der Mat. und Physik}, 27:142--144, 1918.}.
      \item Em 1970, Rényi e Renýi apresentaram uma codificação redundante (ou seja, não bijetiva) para um subconjunto de \emph{$k$-trees} rotuladas que chamamos de \emph{$k$-trees} de Rényi\footnote{\scriptsize C. Rényi, A. Rényi. The prüfer code for $k$-trees. \emph{Combinatorial Theory and its Applications}, 945--971, 1970.}. Definição: Uma \textbf{\emph{$k$-tree} de Rényi} $R_k$ é uma \emph{$k$-tree} enraizada com $n$ vértices rotulados em $[1, n]$ e raiz $\{n-k+1, \cdots, n\}$.
    \end{itemize}
  \end{frame}

  \begin{frame}
    \frametitle{A solução de Caminiti \emph{et al.}}

    \begin{itemize}
      \item Apenas em 2008 surgiu um código bijetivo para \emph{$k$-trees} com algoritmos lineares de codificação e decodificação. Esses algoritmos, propostos por Caminiti \emph{et al.}, foram implementados neste trabalho.
      \item O código é formado por uma permutação de tamanho $k$ e uma generalização do \emph{Dandelion Code}\footnote{\scriptsize Ömer Eğecioğlu, J. B. Remmel. Bijections for cayley trees, spanning trees, and their q-analogues. \emph{Journal of Combinatorial Theory}, 42:15--30, 1986.}. A codificação das \emph{$k$-trees} associa elementos em $\mathcal{T}^n_k$ (conjunto das \emph{$k$-trees} com $n$ vértices) com elementos em:

        $$
        \mathcal{A}^n_k = { [1,n] \choose k } \times (\{ ( 0, \varepsilon ) \} \cup ([1,n-k] \times [1,k]))^{n-k-2}
        $$
    \end{itemize}
  \end{frame}

  \begin{frame}
    \frametitle{A solução de Caminiti \emph{et al.}}

    % TODO: mostrar transformações
  \end{frame}

  \subsection{Geração uniforme}

  \begin{frame}
    \frametitle{Geração uniforme de \emph{$k$-trees}}

    % TODO: algoritmo, implementação, Go
  \end{frame}

  \begin{frame}
    \frametitle{Testes}

    % TODO: testes
  \end{frame}

  \section{Aprendizado de redes bayesianas}

  \subsection{O que são redes bayesianas?}

  \begin{frame}
    \frametitle{O que são redes bayesianas?}

    \textbf{Redes bayesianas} são modelos probabilísticos gráficos\footnote{\scriptsize Daphne Koller, Nir Friedman. \emph{Probabilistic Graphical Models: Principles and Techniques}. The MIT Press, 2009.} que representam distribuições de probabilidade conjunta e são usados para raciocinar em situações com incerteza.

    \vspace{1em}

    {\footnotesize
      Formalmente: Seja $N = \{ 1, \cdots, n \}$ e seja $X = \{X_i : i \in N\}$ um conjunto de variáveis aleatórias $X_i$ tomando valores em conjuntos finitos $\mathcal{X}_i$. Uma \textbf{rede bayesiana} é uma tripla $(X, G, \theta)$, onde $G = (V, E)$ é um DAG (grafo acíclico dirigido, que chamamos de \textbf{estrutura} da rede bayesiana) cujos vértices correspondem a variáveis em $X$ e $\theta = \{\theta_i(x_i, x_{\pi_i})\}$ é um conjunto de parâmetros numéricos especificando valores de probabilidade condicional $\theta_i(x_i, x_{\pi_i}) = P(x_i | x_{\pi_i})$ para todo vértice $i \in V$, valor $x_i \in X_i$ e atribuição $x_{\pi_i}$ para os pais $\pi_i$ de $X_i$ (em $G$).
    }
  \end{frame}

  \begin{frame}
    \frametitle{Exemplo de rede bayesiana}

    \begin{figure}
      \centering
      \scalebox{0.5}{
        \begin{tikzpicture}
            [scale=.5,auto=left,every node/.style={draw, ellipse, inner sep = 3pt, minimum width = 0.72cm, align = center}]

            \node[fill=gray!30] (or) at (1,9) {Supervisor};
            \node[fill=gray!30] (al) at (7,9) {Aluno};
            \node[fill=gray!30] (no) at (2,5) {Nota TCC};
            \node[fill=gray!30] (me) at (10,5) {Média ponderada};
            \node[fill=gray!30] (ca) at (0,1) {Carta de recomendação};

            \path (or) edge[-triangle 60] (no)
              (al) edge[-triangle 60] (no)
              (al) edge[-triangle 60] (me)
              (no) edge[-triangle 60] (ca);

            \node[draw=none,inner sep = 0pt,above=of or]
            {
              \begin{tabular}{|c|c|} \hline
                $o_0$ & $o_1$ \\ \hline
                0,5 & 0,5 \\ \hline
              \end{tabular}
            };

            \node[draw=none,inner sep = 0pt,above=of al]
            {
              \begin{tabular}{|c|c|} \hline
                $a_0$ & $a_1$ \\ \hline
                0,5 & 0,5 \\ \hline
              \end{tabular}
            };

            \node[draw=none,inner sep = 0pt,below=of me]
            {
              \begin{tabular}{|c|c|c|} \hline
                      & $m_0$ & $m_1$ \\ \hline
                $a_0$ & 0,8 & 0,2 \\ \hline
                $a_1$ & 0,2 & 0,8 \\ \hline
              \end{tabular}
            };

            \node[draw=none,inner sep = 0pt,left=of no]
            {
              \begin{tabular}{|c|c|c|} \hline
                      & $n_0$ & $n_1$ \\ \hline
                $a_0,o_0$ & 0,9 & 0,1 \\ \hline
                $a_0,o_1$ & 0,7 & 0,3 \\ \hline
                $a_1,o_0$ & 0,5 & 0,5 \\ \hline
                $a_1,o_1$ & 0,1 & 0,9 \\ \hline
              \end{tabular}
            };

            \node[draw=none,inner sep = 0pt,below=of ca]
            {
              \begin{tabular}{|c|c|c|} \hline
                      & $c_0$ & $c_1$ \\ \hline
                $n_0$ & 0,9 & 0,1 \\ \hline
                $n_1$ & 0,1 & 0,9 \\ \hline
              \end{tabular}
            };
        \end{tikzpicture}
      }

      \caption{Exemplo de rede bayesiana com distribuições de probabilidade condicional.}
      \label{fig:bayes}
    \end{figure}
  \end{frame}

  \subsection{Motivação}

  \begin{frame}
    \frametitle{Aprendizado de redes bayesianas}

    \begin{itemize}
      \item Aprender uma rede bayesiana se refere ao processo de inferir a sua estrutura (i.e., seu DAG) a partir de dados.
      \item Inferência em rede bayesiana é NP-difícil até mesmo aproximadamente e todos os algoritmos conhecidos (exatos e comprovadamente bons) têm complexidade no pior caso exponencial no \emph{treewidth}.
      \item Resultados empíricos sugerem que limitar o \emph{treewidth} pode melhorar a performance dos modelos e não causa perdas significativas na sua expressividade.
      \item Por isso estamos interessados em fixar $k$ e aprender redes bayesianas cujo DAG tem \emph{treewidth} limitado a $k$.
    \end{itemize}
  \end{frame}

  \begin{frame}[fragile=singleslide]
    \frametitle{Aprendizado de redes bayesianas}

    Função de \emph{score} $s(G)$ atribui pontuação para cada DAG $G$ e pode ser escrita como soma de funções de \emph{score} locais:

    {\footnotesize
    $$s(G) = \sum_{i \in N} s_i(X_{\pi_i}).$$
    }

    Para cada variável, sua pontuação só depende do seu conjunto de pais. Portanto, nosso problema é encontrar $G^*$ tal que

    {\footnotesize
    $$G^* = \argmax_{G \in \mathcal{G}_{n,k}} \sum_{i \in N} s_i(\pi_i),$$
    }

    onde $\mathcal{G}_{n,k}$ é o conjunto de todos os DAGs de \emph{treewidth} não maior que $k$. Esse problema é NP-difícil\footnote{\scriptsize Janne H. Korhonen, Pekka Parviainen. Exact learning of bounded tree-width bayesian networks. \emph{Proceedings of the 16th International Conference on AISTATS}, 2013.}.
  \end{frame}

  \subsection{Aprendizado por amostragem de $k$-trees}

  \begin{frame}
    \frametitle{Aprendizado por amostragem de \emph{$k$-trees}}

    A ideia para aprender um DAG por meio da amostragem de \emph{$k$-trees} baseia-se em, para cada \emph{$k$-tree} $T_k$ amostrada, construir uma ordem parcial $\sigma$ dos vértices e fazer com que o DAG $G$ seja consistente com ela e com $T_k$.

    \vspace{1em}

    Construímos a ordem parcial $\sigma$ a partir do enraizamento da \emph{$k$-tree} num $k$-clique qualquer. Em particular, podemos escolher usar a raiz da \emph{$k$-tree} de Rényi que aparece durante a decodificação de um \emph{Dandelion Code} em uma \emph{$k$-tree}.
  \end{frame}

  \begin{frame}
    \frametitle{Algoritmo para aprender estrutura}

    {\footnotesize
      \textbf{Entrada:} $n$, $k$ e função de \emph{score} $s_i$ para cada $i \in [0, n)$\\
      \textbf{Saída:} um DAG $G^{\text{melhor}}$

      \begin{enumerate}
        \item Inicializar $G^{\text{melhor}}$ como um grafo com $s(G^{\text{melhor}}) = -\infty$.
        \item Repetir até atingir um determinado número de iterações:
          \begin{enumerate}
            \item Gerar $(Q, S) \in \mathcal{A}^n_k$ e decodificar $(Q, S)$ na árvore característica $T$;
            \item Sortear ordem pros vértices do $k$-clique raiz e usar função de \emph{score} para calcular os melhores pais para cada um deles;
            \item Percorrer $T$ a partir dos vértices ligados ao $k$-clique raiz: para cada $v$, é sorteado um lugar para ele em $\sigma$ e selecionado seu melhor conjunto de pais dentre os vértices predecessores adjacentes, assim como são atualizados os melhores pais dos vértices sucessores adjacentes;
            \item Se $\left(\sum_{i \in [0,n)} s_i(\pi^G_{i})\right) = s(G) > s(G^{\text{melhor}})$, atualiza $G^{\text{melhor}} = G$.
          \end{enumerate}
      \end{enumerate}
    }
  \end{frame}

  \subsection{Experimentos}

  \begin{frame}
    \frametitle{Experimentos}

    % TODO: resultados
  \end{frame}

  \section{Considerações finais}

  \subsection{Conclusões}

  \begin{frame}
    \frametitle{Conclusão}

    % TODO: escrever
  \end{frame}

  \subsection{Agradecimentos}

  \begin{frame}
    \frametitle{Agradecimentos}

    % TODO: escrever
  \end{frame}

  \begin{frame}
    \frametitle{Perguntas?}

    % TODO: escrever
  \end{frame}
\end{document}
