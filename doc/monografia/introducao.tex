\chapter{Introdução}
\label{cap:introducao}

Em teoria dos grafos, \emph{$k$-trees} são consideradas uma generalização de árvores. Há interesse considerável em desenvolver ferramentas eficientes para manipular essa classe de grafos, porque todo grafo com \emph{treewidth} $k$ é um subgrafo de uma \emph{$k$-tree} e muitos problemas NP-completos podem ser resolvidos em tempo polinomial quando restritos a grafos com \emph{treewidth} limitado.

Alguns exemplos são \cite{arnborg}:

\begin{itemize}
  \item Encontrar o tamanho máximo dos seus conjuntos independentes;
  \item Computar o tamanho mínimo dos seus conjuntos dominantes;
  \item Calcular seu número cromático; e
  \item Determinar se ele tem um ciclo hamiltoniano.
\end{itemize}

Há muitas razões para estudar a geração de \emph{$k$-trees} de forma aleatória, como por exemplo para testar a eficácia de algoritmos aproximados. O problema que desperta nosso interesse em \emph{$k$-trees} é o aprendizado de redes bayesianas.

Uma rede bayesiana é um modelo probabilístico usado para raciocinar e tomar decisões em situações com incerteza através de técnicas de inteligência artificial e aprendizagem computacional. Ela representa de forma concisa uma distribuição de probabilidade multivariada sobre os vértices de um DAG (grafo acíclico dirigido), que representam variáveis aleatórias. As arestas do DAG correspondem, intuitivamente, a influência de uma variável sobre outra.

Segundo Koller e Friedman \cite{koller}, inferência em redes bayesianas é NP-difícil; porém, se seu DAG possui \emph{treewidth} limitado, a inferência pode ser realizada em tempo polinomial no tamanho do grafo. Daí a importância de aprender redes bayesianas que tenham \emph{treewidth} limitado.

O aprendizado de redes bayesianas pode ser visto como o problema de encontrar um DAG que otimize algum valor que caracterize a performance dessa estrutura. Uma técnica simples consiste em gerar DAGs aleatoriamente. Isso garante que o espaço de busca é bem coberto e nos permite adicionalmente obter informações estatísticas sobre o espaço de busca, como por exemplo \emph{score} médio e variância.

Gerar um DAG aleatoriamente e calcular seu \emph{treewidth} é um problema difícil. Porém, Nie \emph{et al.} \cite{maua} sugere um método aproximado para aprender redes bayesianas com \emph{treewidth} limitado que é baseado em amostrar \emph{$k$-trees} e encontrar DAGs cujo grafo moral é um subgrafo dessas \emph{$k$-trees}.

A partir dessa motivação, este trabalho de conclusão de curso consistiu em estudar os conceitos de teoria dos grafos relacionados a \emph{$k$-trees} e implementar um algoritmo para gerar \emph{$k$-trees} de forma uniforme que possam ser usadas no aprendizado de redes bayesianas.

Estudamos e implementamos o algoritmo desenvolvido por Caminiti \emph{et al.} \cite{caminiti} para codificar e decodificar \emph{$k$-trees}. Com base nele, geramos \emph{$k$-trees} uniformemente e usamos as \emph{$k$-trees} geradas para aprender a estrutura de redes bayesianas usando o algoritmo de Nie \emph{et al.} \cite{maua}.

\section{Código desenvolvido}

As implementações deste trabalho foram realizadas na linguagem \emph{Go}\footnote{\emph{The Go Programming Language:} \url{https://golang.org/}}. \emph{Go} é uma linguagem de código aberto criada em 2007 e apoiada pelo Google. Ela é compilada e usa tipagem estática como o C, mas possui recursos avançados como \emph{garbage collection} e bom suporte a programação concorrente.

Escolhemos \emph{Go} porque ela oferece um bom balanço entre a agilidade de escrita de código e a eficiência computacional; tem sistemas de pacotes ({\tt go get}), testes ({\tt go test}) e documentação (\emph{GoDoc}\footnote{\emph{GoDoc:} \url{https://godoc.org/}}) padronizados facilitando que os códigos sejam testados e reutilizados; e ajuda a gerar código limpo e padronizado: identação, espaçamento e outros detalhes de estilo são automatizados pela ferramenta {\tt gofmt}, que vem com ela.

Todo o código desenvolvido neste trabalho está num repositório público no \emph{GitHub}\footnote{\emph{GitHub:} \url{https://github.com/}} cujo endereço é \url{https://github.com/tmadeira/tcc/}.

A documentação de todas as estruturas e funções declaradas no código está disponível em \url{https://godoc.org/github.com/tmadeira/tcc}.

Para baixar o código, rodar os testes e instalar os utilitários, recomenda-se usar as ferramentas da linguagem \emph{Go}:

\begin{lstlisting}
$ export ${GOPATH:=$HOME/go}
$ mkdir -p $GOPATH
$ go get github.com/tmadeira/tcc/...
$ go test -v github.com/tmadeira/tcc/...
$ go install github.com/tmadeira/tcc/examples/...
\end{lstlisting}

\section{Organização da monografia}

No capítulo \ref{cap:fundamentos}, apresentamos definições fundamentais de teoria dos grafos que o leitor deve conhecer para compreender o trabalho.

No capítulo \ref{cap:geracao}, apresentamos o problema de codificar \emph{$k$-trees}, discutimos os algoritmos lineares para codificar e decodificar \emph{$k$-trees} propostos no artigo \emph{``Bijective Linear Time Coding and Decoding for $k$-Trees''} \cite{caminiti}, explicamos como eles foram implementados neste trabalho para gerar \emph{$k$-trees} aleatórias uniformemente e apresentamos o resultado que obtivemos através de experimentos.

No capítulo \ref{cap:aprendizado}, explicamos como as \emph{$k$-trees} que geramos no capítulo \ref{cap:geracao} podem ser usadas para aprender redes bayesianas a partir do arcabouço desenvolvido no artigo \emph{``Advances in Learning Bayesian Networks of Bounded Treewidth''} \cite{maua} e apresentamos os resultados obtidos.

No capítulo \ref{cap:conclusao}, apresentamos conclusões e apontamos possíveis desdobramentos do trabalho.
