\chapter{Introdução}
\label{cap:introducao}

Em teoria dos grafos, \emph{$k$-trees} são consideradas uma generalização de árvores. Há interesse considerável em desenvolver ferramentas eficientes para manipular essa classe de grafos, porque todo grafo com \emph{treewidth} $k$ é um subgrafo de uma \emph{$k$-tree} e muitos problemas NP-completos podem ser resolvidos em tempo polinomial quando restritos a grafos com \emph{treewidth} limitada.

Com efeito, o artigo de Arnborg e Proskurowski \cite{arnborg} apresenta algoritmos para resolver em tempo linear problemas como, dado um grafo com \emph{treewidth} limitada:

\begin{itemize}
  \item Encontrar o tamanho máximo dos seus conjuntos independentes;
  \item Computar o tamanho mínimo dos seus conjuntos dominantes;
  \item Calcular seu número cromático; e
  \item Determinar se ele tem um ciclo hamiltoniano.
\end{itemize}

O problema que desperta nosso interesse em \emph{$k$-trees} é a inferência em redes bayesianas.

Uma rede bayesiana é um modelo probabilístico em grafo usado para raciocinar e tomar decisões em situações com incerteza através de técnicas de inteligência artificial e aprendizagem computacional. Ela representa uma distribuição de probabilidade multivariada num DAG (grafo acíclico dirigido) no qual os vértices correspondem às variáveis aleatórias do domínio e as arestas correspondem, intuitivamente, a influência de uma variável sobre outra.

Segundo Koller e Friedman \cite{koller}, a inferência em redes bayesianas em geral é NP-difícil; porém, se seu DAG possui \emph{treewidth} limitado, a inferência pode ser realizada em tempo polinomial. Daí a importância de aprender redes bayesianas que tenham \emph{treewidth} limitada.

A partir dessa motivação, este trabalho de conclusão de curso consistiu em estudar os conceitos de teoria dos grafos relacionados a \emph{$k$-trees} e implementar um algoritmo para gerar \emph{$k$-trees} de forma uniforme que possam ser usadas no aprendizado de redes bayesianas.

\section{Código desenvolvido}

As implementações deste trabalho foram realizadas na linguagem \emph{Go}\footnote{\emph{The Go Programming Language:} \url{https://golang.org/}}. \emph{Go} é uma linguagem de código aberto criada em 2007. Ela é compilada e usa tipagem estática como o C, mas por ser uma linguagem muito nova tem \emph{garbage collection} e recursos para programação concorrente.

Escolhemos \emph{Go} porque ela tem boa performance e é agradável de usar. Tem sistemas de pacotes ({\tt go get}), testes ({\tt go test}) e documentação (\emph{GoDoc}\footnote{\emph{GoDoc:} \url{https://godoc.org/}}) padronizados facilitando que os códigos sejam testados e reutilizados. Produz código limpo e padronizado (identação, espaçamento e outros detalhes de estilo são automatizados pela ferramenta {\tt gofmt} que vem com ela).

Todo o código desenvolvido neste trabalho está num repositório público no \emph{GitHub}\footnote{\emph{GitHub:} \url{https://github.com/}} cujo endereço é \url{https://github.com/tmadeira/tcc/}.

A documentação de todas as estruturas e funções declaradas no código está disponível em \url{https://godoc.org/github.com/tmadeira/tcc}.

Para baixar o código, rodar os testes e instalar os utilitários, recomenda-se usar as ferramentas da linguagem \emph{Go}:

\begin{lstlisting}
$ export ${GOPATH:=$HOME/go}
$ mkdir -p $GOPATH
$ go get github.com/tmadeira/tcc/...
$ go test -v github.com/tmadeira/tcc/...
$ go install github.com/tmadeira/tcc/examples/...
\end{lstlisting}

\section{Organização da monografia}

No capítulo \ref{cap:fundamentos}, apresentamos definições fundamentais de teoria dos grafos, teoria da probabilidade e redes bayesianas que o leitor deve conhecer para compreender o trabalho.

No capítulo \ref{cap:geracao}, apresentamos o problema de codificar \emph{$k$-trees}, discutimos os algoritmos lineares para codificar e decodificar \emph{$k$-trees} propostos no artigo \emph{``Bijective Linear Time Coding and Decoding for $k$-Trees''} \cite{caminiti}, explicamos como eles foram implementados neste trabalho para gerar \emph{$k$-trees} aleatórias uniformemente e apresentamos o resultado que obtivemos através de experimentos.

No capítulo \ref{cap:aprendizado}, explicamos como as \emph{$k$-trees} que geramos no capítulo \ref{cap:geracao} foram usadas para aprender redes bayesianas a partir do arcabouço desenvolvido no artigo \emph{``Advances in Learning Bayesian Networks of Bounded Treewidth''} \cite{maua}.

No capítulo \ref{cap:conclusao}, comparamos os resultados obtidos com o estado da arte e listamos as conclusões do trabalho.
